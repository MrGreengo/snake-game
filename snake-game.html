<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Snake Game with Letter Blocks</title>
  <style>
    /* === Container that holds the game and the puzzle/word info === */
    .game-wrapper {
      display: flex;
      align-items: flex-start; /* keep top aligned */
      margin: 0 40px; /* 40px margin left & right, as requested */
    }

    /* === The canvas for the snake game === */
    #gameCanvas {
      border: 1px solid #000;
      background-color: #fafafa;
      width: 585px;
      height: 585px;
      /* Force a 1:1 ratio on high-DPI screens by controlling the actual
         drawing buffer separately in JS, or use the style size as needed. */
      display: block;
    }

    /* === Puzzle area on the right side === */
    .puzzle-area {
      margin-left: 20px; /* Spacing from the game canvas */
      font-family: sans-serif;
    }

    .puzzle-area h2 {
      margin: 0 0 10px;
    }

    .puzzle-area .word {
      font-size: 1.5em;
      margin-bottom: 10px;
    }
  </style>
</head>
<body>

  <div class="game-wrapper">
    <!-- The Snake Game Canvas -->
    <canvas id="gameCanvas" width="585" height="585"></canvas>

    <!-- Puzzle / Word Info -->
    <div class="puzzle-area">
      <h2>Find the Missing Letter</h2>
      <div class="word" id="wordDisplay">c_t</div>
      <div>Controls: Arrow keys or swipe on the canvas</div>
    </div>
  </div>

  <script>
    // === GLOBALS ===
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // You can treat the board as a grid. For example:
    // 13 x 13 cells of 45px each = 585px total
    const cols = 13;
    const rows = 13;
    const cellSize = 45;

    // Snake initial setup (start in the middle)
    let snake = [
      { x: 6, y: 6 } // middle of a 13x13 grid
    ];
    let direction = { x: 0, y: 0 }; // initial direction = none (standing still)
    let snakeSpeed = 5; // move steps per second
    let lastFrameTime = 0;

    // We can store multiple letter “foods”
    // e.g., "a" is the correct letter, "e", "f" are distractors.
    let foods = [
      { x: 2,  y: 2,  letter: 'a' },
      { x: 10, y: 10, letter: 'e' },
      { x: 5,  y: 8,  letter: 'f' }
    ];
    const correctLetter = 'a';
    let puzzleWord = 'c_t'; // shown to user; try to fill the underscore

    // --- KEYBOARD CONTROL ---
    document.addEventListener('keydown', (e) => {
      switch (e.key) {
        case 'ArrowUp':
          if (direction.y === 1) break; // prevent going down->up instantly
          direction = { x: 0, y: -1 };
          break;
        case 'ArrowDown':
          if (direction.y === -1) break;
          direction = { x: 0, y: 1 };
          break;
        case 'ArrowLeft':
          if (direction.x === 1) break;
          direction = { x: -1, y: 0 };
          break;
        case 'ArrowRight':
          if (direction.x === -1) break;
          direction = { x: 1, y: 0 };
          break;
      }
    });

    // --- TOUCH / SWIPE CONTROL ---
    let touchStartX = 0;
    let touchStartY = 0;

    canvas.addEventListener('touchstart', (e) => {
      const touch = e.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
    });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault(); // prevent scrolling on mobile
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
      const touch = e.changedTouches[0];
      const deltaX = touch.clientX - touchStartX;
      const deltaY = touch.clientY - touchStartY;

      // Determine swipe direction
      if (Math.abs(deltaX) > Math.abs(deltaY)) {
        // Left or Right
        if (deltaX > 0 && direction.x !== -1) {
          direction = { x: 1, y: 0 };
        } else if (deltaX < 0 && direction.x !== 1) {
          direction = { x: -1, y: 0 };
        }
      } else {
        // Up or Down
        if (deltaY > 0 && direction.y !== -1) {
          direction = { x: 0, y: 1 };
        } else if (deltaY < 0 && direction.y !== 1) {
          direction = { x: 0, y: -1 };
        }
      }
    });

    // === GAME LOOP ===
    function gameLoop(timestamp) {
      requestAnimationFrame(gameLoop);
      
      const secondsSinceLastFrame = (timestamp - lastFrameTime) / 1000;
      if (secondsSinceLastFrame < (1 / snakeSpeed)) {
        return; // limit update rate
      }
      lastFrameTime = timestamp;

      update();
      draw();
    }

    // === UPDATE LOGIC ===
    function update() {
      // 1. Move snake
      const head = { ...snake[0] };
      head.x += direction.x;
      head.y += direction.y;

      // Wrap the snake if it goes off the edge (typical Snake feature)
      if (head.x < 0) head.x = cols - 1;
      if (head.x >= cols) head.x = 0;
      if (head.y < 0) head.y = rows - 1;
      if (head.y >= rows) head.y = 0;

      // 2. Check if snake hits food
      for (let i = 0; i < foods.length; i++) {
        if (head.x === foods[i].x && head.y === foods[i].y) {
          // If the letter is the correct one, fill the puzzle
          if (foods[i].letter === correctLetter) {
            puzzleWord = puzzleWord.replace('_', correctLetter); // replace underscore with correct letter
            document.getElementById('wordDisplay').textContent = puzzleWord;
            
            // You can trigger a "success" or next-level flow here
            // For demonstration, just remove the correct letter from the board
          }
          // Remove that food from the array
          foods.splice(i, 1);
          i--;
          
          // Grow snake by 1
          snake.unshift(head);
          return; // finish update here (snake has grown)
        }
      }

      // 3. Move snake body
      // Remove last segment if we didn't grow
      snake.unshift(head);
      snake.pop();
    }

    // === DRAW LOGIC ===
    function draw() {
      // Clear the board
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw snake
      ctx.fillStyle = '#008000';
      snake.forEach((segment) => {
        ctx.fillRect(segment.x * cellSize, segment.y * cellSize, cellSize, cellSize);
      });

      // Draw food (letter blocks)
      foods.forEach((food) => {
        // Fill block background
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(food.x * cellSize, food.y * cellSize, cellSize, cellSize);
        // Draw letter
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 20px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(
          food.letter.toUpperCase(),
          (food.x * cellSize) + cellSize / 2,
          (food.y * cellSize) + cellSize / 2
        );
      });
    }

    // Start game loop
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
