<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Mr. Green's Snake Game (Word Puzzles) - Beta Test</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      background-color: #333; color: #fff;
      font-family: Arial, sans-serif;
    }
    body {
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: flex-start;
    }
    #gameContainer {
      width: 585px; height: 585px;
      margin-left: 40px; margin-right: 40px;
      display: flex;
      align-items: center; justify-content: center;
    }
    #gameCanvas {
      background-color: #000;
      border: 1px solid #fff;
      display: block;
      touch-action: none; /* Disables default scrolling on touch */
    }
    #rightSide {
      flex: 1;
      display: flex; 
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
      height: 100%;
    }
    #gameTitle {
      margin-top: 20px;
      font-size: 1.5rem;
    }
    #puzzleWord {
      margin-top: 20px;
      font-size: 8rem;
      text-align: center;
    }
    #puzzleImage {
      margin-top: 20px; 
      max-width: 200px;
    }
    #scoreBoard {
      margin-top: 20px;
      margin-bottom: 10px;
      font-size: 2rem;
    }
    #highScoreBoard {
      margin-top: auto;
      margin-bottom: 40px;
      font-size: 2rem;
    }
    #footer {
      position: fixed; bottom: 0; width: 100%;
      text-align: center; background-color: #333;
      color: #fff; padding: 10px 0; font-size: 1rem;
      border-top: 1px solid #fff; 
    }
    /***** Overlay *****/
    #resultsOverlay {
      display: none;
      position: fixed; top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 9999;
      align-items: center; justify-content: center;
      flex-direction: column; color: #fff;
    }
    #resultsOverlayContent {
      background: #444; padding: 20px; margin: 20px;
      border: 1px solid #fff; border-radius: 6px; max-width: 600px;
    }
    #closeOverlayBtn {
      background: #888; border: 1px solid #fff; color: #fff;
      padding: 10px 20px; margin: 10px; font-size: 1rem; cursor: pointer;
      border-radius: 4px;
    }
    #closeOverlayBtn:hover {
      background: #aaa;
    }
  </style>
</head>
<body>

  <!-- LEFT: The game container -->
  <div id="gameContainer">
    <canvas id="gameCanvas" width="585" height="585"></canvas>
  </div>

  <!-- RIGHT: Title, Puzzle Word, Puzzle Image, Score -->
  <div id="rightSide">
    <h1 id="gameTitle">Mr. Green's Snake Game</h1>
    <div id="puzzleWord">---</div>
    <img id="puzzleImage" src="" alt="Puzzle Image" />
    <div id="scoreBoard">
      Score: <span id="scoreValue">0</span>
    </div>
    <div id="highScoreBoard">
      High Score: <span id="highScoreValue">0</span>
    </div>
  </div>

  <!-- Footer -->
  <div id="footer">
    &copy; 2025 Greengo EdTech
  </div>

  <!-- Results overlay, hidden by default -->
  <div id="resultsOverlay">
    <div id="resultsOverlayContent">
      <!-- We'll fill this with HTML in resetGame() -->
    </div>
    <button id="closeOverlayBtn">Close</button>
  </div>

  <script>
/*************************************************************
 *                 GAME & PUZZLE VARIABLES
 *************************************************************/
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const gridSize = 45;               // each cell is 45px => 13 columns in 585px
const cols = canvas.width / gridSize;
const rows = canvas.height / gridSize;

const mid = Math.floor(cols / 2);  // Snake starts near center
let snake = [
  { x: mid,     y: mid },
  { x: mid - 1, y: mid },
  { x: mid - 2, y: mid }
];
let oldSnake = snake.map(s => ({ ...s }));

// Direction & flow
let direction = null;
let prevDirection = 'RIGHT';
let gameStarted = false;

// Swipe
let touchStartX = 0, touchStartY = 0;

// Movement timing
let lastTimestamp = 0;
let accumulator = 0;
let moveInterval = 150;

// Score
let score = 0;
let highScore = 0;

// DOM references
const scoreValueEl = document.getElementById('scoreValue');
const highScoreValueEl = document.getElementById('highScoreValue');
const puzzleWordEl = document.getElementById('puzzleWord');
const puzzleImageEl = document.getElementById('puzzleImage');

// Puzzle data
let currentPuzzle = null;
let lettersOnBoard = [];
const puzzleHistory = []; // track puzzle attempts

// For open-mouth animation
let aboutToEat = false;

/*************************************************************
 *                TOUCH EVENT LISTENERS (One-Time Only)
 *************************************************************/
canvas.addEventListener('touchstart', function(e) {
  e.preventDefault();
  const touch = e.touches[0];
  touchStartX = touch.clientX;
  touchStartY = touch.clientY;
}, { passive: false });

canvas.addEventListener('touchmove', function(e) {
  e.preventDefault();
}, { passive: false });

canvas.addEventListener('touchend', function(e) {
  e.preventDefault();
  const touch = e.changedTouches[0];
  const dx = touch.clientX - touchStartX;
  const dy = touch.clientY - touchStartY;
  const absDx = Math.abs(dx);
  const absDy = Math.abs(dy);

  // Determine swipe direction
  if (absDx > absDy) {
    // Horizontal
    if (dx > 0 && prevDirection !== 'LEFT') {
      direction = 'RIGHT';
    } else if (dx < 0 && prevDirection !== 'RIGHT') {
      direction = 'LEFT';
    }
  } else {
    // Vertical
    if (dy > 0 && prevDirection !== 'UP') {
      direction = 'DOWN';
    } else if (dy < 0 && prevDirection !== 'DOWN') {
      direction = 'UP';
    }
  }

  // Start game on first valid swipe
  if (!gameStarted && direction !== null) {
    gameStarted = true;
  }
}, { passive: false });

/*************************************************************
 *                 KEYBOARD CONTROLS
 *************************************************************/
document.addEventListener('keydown', onKeyDown);
function onKeyDown(e) {
  const key = e.key;

  // If game not started, first press sets direction & starts
  if (!gameStarted) {
    let desiredDir = null;
    if (key === 'ArrowLeft'  || key === 'a') desiredDir = 'LEFT';
    if (key === 'ArrowUp'    || key === 'w') desiredDir = 'UP';
    if (key === 'ArrowRight' || key === 'd') desiredDir = 'RIGHT';
    if (key === 'ArrowDown'  || key === 's') desiredDir = 'DOWN';

    if (desiredDir) {
      // Avoid immediate reverse
      if (!isOpposite(desiredDir, prevDirection)) {
        direction = desiredDir;
        prevDirection = desiredDir;
        gameStarted = true;
        lastTimestamp = performance.now();
        accumulator = 0;
      }
    }
    return;
  }

  // Once started, normal direction logic
  switch (key) {
    case 'ArrowLeft':
    case 'a':
      if (prevDirection !== 'RIGHT') direction = 'LEFT';
      break;
    case 'ArrowUp':
    case 'w':
      if (prevDirection !== 'DOWN') direction = 'UP';
      break;
    case 'ArrowRight':
    case 'd':
      if (prevDirection !== 'LEFT') direction = 'RIGHT';
      break;
    case 'ArrowDown':
    case 's':
      if (prevDirection !== 'UP') direction = 'DOWN';
      break;
  }
}
function isOpposite(d1, d2) {
  return (
    (d1 === 'LEFT'  && d2 === 'RIGHT') ||
    (d1 === 'RIGHT' && d2 === 'LEFT')  ||
    (d1 === 'UP'    && d2 === 'DOWN')  ||
    (d1 === 'DOWN'  && d2 === 'UP')
  );
}

/*************************************************************
 *                SPEED PROMPT FUNCTION
 *************************************************************/
function promptSpeedSelection() {
  const choice = prompt(
    "Choose snake speed:\n" +
    "  (e) Easy (slower)\n" +
    "  (m) Medium\n" +
    "  (h) Hard (faster)\n\n" +
    "Enter e, m, or h:"
  );
  if (!choice) {
    moveInterval = 150;  // default to medium
    return;
  }
  switch (choice.toLowerCase()) {
    case 'e': moveInterval = 200; break; // slower
    case 'h': moveInterval = 100; break; // faster
    case 'm':
    default:
      moveInterval = 150;         // medium
      break;
  }
  alert(`Speed set to ${moveInterval} ms per move.`);
}

/*************************************************************
 *                   PUZZLE SETUP
 *************************************************************/
// Example puzzle library truncated for brevity, but you have them all
const puzzleLibrary = [
  { pattern: "c_t", correct: "a", distractors: ["k","i"], imgSrc: "..." },
  // ...
];

function pickNewPuzzle() {
  const idx = Math.floor(Math.random() * puzzleLibrary.length);
  currentPuzzle = puzzleLibrary[idx];

  // Display puzzle
  puzzleWordEl.textContent = currentPuzzle.pattern;
  puzzleImageEl.src = currentPuzzle.imgSrc;

  // Place letters
  lettersOnBoard = [];
  const chars = [
    { char: currentPuzzle.correct, isCorrect: true },
    { char: currentPuzzle.distractors[0], isCorrect: false },
    { char: currentPuzzle.distractors[1], isCorrect: false }
  ];
  shuffleArray(chars);

  chars.forEach(letterObj => {
    let placed = false;
    while (!placed) {
      const rx = Math.floor(Math.random() * cols);
      const ry = Math.floor(Math.random() * rows);

      const snakeOccupies = snake.some(seg => seg.x === rx && seg.y === ry);
      const letterOccupies = lettersOnBoard.some(l => l.x === rx && l.y === ry);

      if (!snakeOccupies && !letterOccupies) {
        lettersOnBoard.push({
          x: rx, y: ry,
          char: letterObj.char,
          isCorrect: letterObj.isCorrect
        });
        placed = true;
      }
    }
  });
}
function shuffleArray(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

function handleLetterGobble(letter) {
  // Rebuild the full puzzle word
  const fullWord = currentPuzzle.pattern.replace("_", currentPuzzle.correct);
  if (letter.isCorrect) {
    puzzleHistory.push({
      pattern: currentPuzzle.pattern,
      correctAnswer: fullWord,
      wasCorrect: true
    });
    score++;
    scoreValueEl.textContent = String(score);
    pickNewPuzzle();
  } else {
    puzzleHistory.push({
      pattern: currentPuzzle.pattern,
      correctAnswer: fullWord,
      wasCorrect: false
    });
    // Wrong => game over
    resetGame();
  }
}

/*************************************************************
 *                    COLLISION & RESET
 *************************************************************/
function checkCollision(x, y) {
  // Walls
  if (x < 0 || x >= cols || y < 0 || y >= rows) {
    return true;
  }
  // Snake body collision (skip head i=0)
  for (let i = 1; i < snake.length; i++) {
    if (snake[i].x === x && snake[i].y === y) {
      return true;
    }
  }
  return false;
}

function resetGame() {
  // 1) If user’s final score beats the highScore, update it
  if (score > highScore) {
    highScore = score;
    highScoreValueEl.textContent = highScore;
  }

  // 2) Show overlay with results
  const correctWord = currentPuzzle.pattern.replace("_", currentPuzzle.correct);
  const html = `
    <h2>Game Over!</h2>
    <p>Your score was: <strong>${score}</strong></p>
    <p>The correct word is:</p>
    <p style="font-size: 2rem; font-weight: bold;">${correctWord}</p>
    <img src="${currentPuzzle.imgSrc}" 
         alt="Puzzle Image" 
         style="margin-top: 10px; max-width: 200px; border-radius: 8px;" />
  `;
  const overlayContent = document.getElementById('resultsOverlayContent');
  overlayContent.innerHTML = html;

  const overlay = document.getElementById('resultsOverlay');
  overlay.style.display = "flex";

  // 3) Hook the "Close" button to performGameReset() *once*
  const closeBtn = document.getElementById('closeOverlayBtn');
  closeBtn.addEventListener('click', () => {
    overlay.style.display = "none";
    performGameReset();
  }, { once: true });
}

// The actual re-initialization for a new game
function performGameReset() {
  // Reset score
  score = 0;
  scoreValueEl.textContent = "0";

  // Reset direction flags
  direction = null;
  prevDirection = 'RIGHT';
  aboutToEat = false;
  gameStarted = false;

  // Reset snake
  snake = [
    { x: mid, y: mid },
    { x: mid - 1, y: mid },
    { x: mid - 2, y: mid }
  ];
  oldSnake = snake.map(s => ({ ...s }));

  // Reset puzzle
  lettersOnBoard = [];
  pickNewPuzzle();

  // Reset timers
  accumulator = 0;
  lastTimestamp = 0;
}

/*************************************************************
 *                      MAIN LOOP
 *************************************************************/
function mainLoop(timestamp) {
  const overlay = document.getElementById('resultsOverlay');
  // If overlay is up, pause game updates
  if (overlay.style.display === "flex") {
    requestAnimationFrame(mainLoop);
    return;
  }

  const deltaTime = timestamp - lastTimestamp;
  lastTimestamp = timestamp;
  accumulator += deltaTime;

  if (gameStarted) {
    while (accumulator >= moveInterval) {
      updateLogic();
      accumulator -= moveInterval;
    }
  } else {
    // Just track old positions so rendering is stable
    oldSnake = snake.map(s => ({ ...s }));
  }
  const interpolation = accumulator / moveInterval;
  draw(interpolation);

  requestAnimationFrame(mainLoop);
}

function updateLogic() {
  oldSnake = snake.map(s => ({ ...s }));
  if (!direction) return; // No movement

  let nextX = snake[0].x;
  let nextY = snake[0].y;
  switch (direction) {
    case 'LEFT':  nextX--; break;
    case 'UP':    nextY--; break;
    case 'RIGHT': nextX++; break;
    case 'DOWN':  nextY++; break;
  }

  // Check if there's a letter
  const letterAtPosition = lettersOnBoard.find(l => l.x === nextX && l.y === nextY);
  aboutToEat = !!letterAtPosition;

  // Add new head
  snake.unshift({ x: nextX, y: nextY });

  if (letterAtPosition) {
    // If correct => continue, if wrong => resetGame() inside handleLetterGobble
    handleLetterGobble(letterAtPosition);
    // If handleLetterGobble triggered a resetGame() for wrong letter, we can stop here
    if (!letterAtPosition.isCorrect) return;
  } else {
    // Remove tail if no letter eaten
    snake.pop();
  }

  // Check collisions
  if (checkCollision(nextX, nextY)) {
    resetGame();
  }

  // Update prevDirection so we can’t reverse immediately
  prevDirection = direction;
}

function draw(interpolation) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  // Draw snake
  for (let i = 0; i < snake.length; i++) {
    const cur = snake[i];
    const old = oldSnake[i] || cur;

    const x = old.x + interpolation * (cur.x - old.x);
    const y = old.y + interpolation * (cur.y - old.y);

    if (i === 0) {
      drawSnakeHead(x, y, aboutToEat);
    } else {
      ctx.fillStyle = 'limegreen';
      ctx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);
    }
  }

  // Draw letters
  lettersOnBoard.forEach(letter => {
    ctx.fillStyle = 'red';
    ctx.fillRect(letter.x * gridSize, letter.y * gridSize, gridSize, gridSize);

    ctx.fillStyle = 'white';
    ctx.font = '30px Helvetica';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    const centerX = (letter.x + 0.5) * gridSize;
    const centerY = (letter.y + 0.5) * gridSize;
    ctx.fillText(letter.char, centerX, centerY);
  });
}

function drawSnakeHead(x, y, openMouth) {
  ctx.fillStyle = 'limegreen';
  ctx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);

  // Eyes
  ctx.fillStyle = 'black';
  ctx.fillRect(x * gridSize + gridSize * 0.2, y * gridSize + gridSize * 0.2, 4, 4);
  ctx.fillRect(x * gridSize + gridSize * 0.6, y * gridSize + gridSize * 0.2, 4, 4);

  // Mouth
  if (openMouth) {
    ctx.fillStyle = 'black';
    ctx.fillRect(
      x * gridSize,
      y * gridSize + gridSize * 0.5,
      gridSize,
      gridSize * 0.5
    );
    ctx.fillStyle = 'red';
    ctx.fillRect(
      x * gridSize + gridSize * 0.4,
      y * gridSize + gridSize * 0.7,
      gridSize * 0.2,
      gridSize * 0.3
    );
  } else {
    ctx.beginPath();
    ctx.moveTo(x * gridSize + gridSize * 0.3, y * gridSize + gridSize * 0.8);
    ctx.lineTo(x * gridSize + gridSize * 0.7, y * gridSize + gridSize * 0.8);
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 2;
    ctx.stroke();
  }
}

/*************************************************************
 *                     INITIAL SETUP
 *************************************************************/
promptSpeedSelection();
pickNewPuzzle(); // load initial puzzle
draw(1.0);       // draw once before starting
requestAnimationFrame(mainLoop);
  </script>
</body>
</html>

